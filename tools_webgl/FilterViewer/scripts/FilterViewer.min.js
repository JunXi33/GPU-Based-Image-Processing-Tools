var __extends=(this&&this.__extends)||(function(){var a=Object.setPrototypeOf||({__proto__:[]} instanceof Array&&function(e,c){e.__proto__=c})||function(f,c){for(var e in c){if(c.hasOwnProperty(e)){f[e]=c[e]}}};return function(f,c){a(f,c);function e(){this.constructor=f}f.prototype=c===null?Object.create(c):(e.prototype=c.prototype,new e())}})();var EcognitaMathLib;(function(a){function b(d){var c=new Image();c.src=d;return c}a.imread=b})(EcognitaMathLib||(EcognitaMathLib={}));var EcognitaMathLib;(function(b){function a(q,z,y,x){if(z>1||y>1||x>1){return}var d=q%360;var p=Math.floor(d/60);var u=d/60-p;var j=y*(1-z);var e=y*(1-z*u);var o=y*(1-z*(1-u));var l=new Array();if(!(z>0)&&!(z<0)){l.push(y,y,y,x)}else{var c=new Array(y,e,j,j,o,y);var t=new Array(o,y,y,e,j,j);var w=new Array(j,j,o,y,y,e);l.push(c[p],t[p],w[p],x)}return l}b.HSV2RGB=a})(EcognitaMathLib||(EcognitaMathLib={}));var EcognitaMathLib;(function(b){var a=(function(){function c(d){this.hm=new Hammer(d);this.on_pan=undefined}c.prototype.enablePan=function(){if(this.on_pan==undefined){console.log("please setting the PAN function!");return}this.hm.add(new Hammer.Pan({direction:Hammer.DIRECTION_ALL,threshold:0}));this.hm.on("pan",this.on_pan)};return c}());b.Hammer_Utils=a})(EcognitaMathLib||(EcognitaMathLib={}));var EcognitaMathLib;(function(a){var b=(function(){function c(){this.inverse=function(D){var ab=this.create();var ag=D[0],af=D[1],ae=D[2],ad=D[3],ac=D[4],aa=D[5],Z=D[6],Y=D[7],X=D[8],W=D[9],V=D[10],U=D[11],T=D[12],S=D[13],R=D[14],Q=D[15],O=ag*aa-af*ac,M=ag*Z-ae*ac,L=ag*Y-ad*ac,K=af*Z-ae*aa,J=af*Y-ad*aa,I=ae*Y-ad*Z,H=X*S-W*T,G=X*R-V*T,F=X*Q-U*T,E=W*R-V*S,P=W*Q-U*S,N=V*Q-U*R,C=1/(O*N-M*P+L*E+K*F-J*G+I*H);ab[0]=(aa*N-Z*P+Y*E)*C;ab[1]=(-af*N+ae*P-ad*E)*C;ab[2]=(S*I-R*J+Q*K)*C;ab[3]=(-W*I+V*J-U*K)*C;ab[4]=(-ac*N+Z*F-Y*G)*C;ab[5]=(ag*N-ae*F+ad*G)*C;ab[6]=(-T*I+R*L-Q*M)*C;ab[7]=(X*I-V*L+U*M)*C;ab[8]=(ac*P-aa*F+Y*H)*C;ab[9]=(-ag*P+af*F-ad*H)*C;ab[10]=(T*J-S*L+Q*O)*C;ab[11]=(-X*J+W*L-U*O)*C;ab[12]=(-ac*E+aa*G-Z*H)*C;ab[13]=(ag*E-af*G+ae*H)*C;ab[14]=(-T*K+S*M-R*O)*C;ab[15]=(X*K-W*M+V*O)*C;return ab}}c.prototype.create=function(){return new Float32Array(16)};c.prototype.identity=function(d){d[0]=1;d[1]=0;d[2]=0;d[3]=0;d[4]=0;d[5]=1;d[6]=0;d[7]=0;d[8]=0;d[9]=0;d[10]=1;d[11]=0;d[12]=0;d[13]=0;d[14]=0;d[15]=1;return d};c.prototype.multiply=function(u,s){var aj=this.create();var ao=u[0],an=u[1],am=u[2],al=u[3],ak=u[4],ai=u[5],ah=u[6],ag=u[7],af=u[8],ae=u[9],ad=u[10],ac=u[11],ab=u[12],aa=u[13],Z=u[14],Y=u[15],X=s[0],W=s[1],V=s[2],U=s[3],T=s[4],S=s[5],R=s[6],Q=s[7],z=s[8],y=s[9],x=s[10],w=s[11],v=s[12],t=s[13],r=s[14],q=s[15];aj[0]=X*ao+W*ak+V*af+U*ab;aj[1]=X*an+W*ai+V*ae+U*aa;aj[2]=X*am+W*ah+V*ad+U*Z;aj[3]=X*al+W*ag+V*ac+U*Y;aj[4]=T*ao+S*ak+R*af+Q*ab;aj[5]=T*an+S*ai+R*ae+Q*aa;aj[6]=T*am+S*ah+R*ad+Q*Z;aj[7]=T*al+S*ag+R*ac+Q*Y;aj[8]=z*ao+y*ak+x*af+w*ab;aj[9]=z*an+y*ai+x*ae+w*aa;aj[10]=z*am+y*ah+x*ad+w*Z;aj[11]=z*al+y*ag+x*ac+w*Y;aj[12]=v*ao+t*ak+r*af+q*ab;aj[13]=v*an+t*ai+r*ae+q*aa;aj[14]=v*am+t*ah+r*ad+q*Z;aj[15]=v*al+t*ag+r*ac+q*Y;return aj};c.prototype.scale=function(f,d){var e=this.create();if(d.length!=3){return undefined}e[0]=f[0]*d[0];e[1]=f[1]*d[0];e[2]=f[2]*d[0];e[3]=f[3]*d[0];e[4]=f[4]*d[1];e[5]=f[5]*d[1];e[6]=f[6]*d[1];e[7]=f[7]*d[1];e[8]=f[8]*d[2];e[9]=f[9]*d[2];e[10]=f[10]*d[2];e[11]=f[11]*d[2];e[12]=f[12];e[13]=f[13];e[14]=f[14];e[15]=f[15];return e};c.prototype.translate=function(f,d){var e=this.create();if(d.length!=3){return undefined}e[0]=f[0];e[1]=f[1];e[2]=f[2];e[3]=f[3];e[4]=f[4];e[5]=f[5];e[6]=f[6];e[7]=f[7];e[8]=f[8];e[9]=f[9];e[10]=f[10];e[11]=f[11];e[12]=f[0]*d[0]+f[4]*d[1]+f[8]*d[2]+f[12];e[13]=f[1]*d[0]+f[5]*d[1]+f[9]*d[2]+f[13];e[14]=f[2]*d[0]+f[6]*d[1]+f[10]*d[2]+f[14];e[15]=f[3]*d[0]+f[7]*d[1]+f[11]*d[2]+f[15];return e};c.prototype.rotate=function(C,aa,B){var ab=this.create();if(B.length!=3){return undefined}var V=Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]);if(!V){return undefined}var ag=B[0],af=B[1],ae=B[2];if(V!=1){V=1/V;ag*=V;af*=V;ae*=V}var ad=Math.sin(aa),ac=Math.cos(aa),Z=1-ac,Y=C[0],X=C[1],W=C[2],U=C[3],T=C[4],S=C[5],R=C[6],Q=C[7],P=C[8],O=C[9],M=C[10],L=C[11],K=ag*ag*Z+ac,J=af*ag*Z+ae*ad,I=ae*ag*Z-af*ad,H=ag*af*Z-ae*ad,G=af*af*Z+ac,F=ae*af*Z+ag*ad,E=ag*ae*Z+af*ad,D=af*ae*Z-ag*ad,N=ae*ae*Z+ac;if(aa){if(C!=ab){ab[12]=C[12];ab[13]=C[13];ab[14]=C[14];ab[15]=C[15]}}else{ab=C}ab[0]=Y*K+T*J+P*I;ab[1]=X*K+S*J+O*I;ab[2]=W*K+R*J+M*I;ab[3]=U*K+Q*J+L*I;ab[4]=Y*H+T*G+P*F;ab[5]=X*H+S*G+O*F;ab[6]=W*H+R*G+M*F;ab[7]=U*H+Q*G+L*F;ab[8]=Y*E+T*D+P*N;ab[9]=X*E+S*D+O*N;ab[10]=W*E+R*D+M*N;ab[11]=U*E+Q*D+L*N;return ab};c.prototype.viewMatrix=function(m,x,j){var t=this.identity(this.create());if(m.length!=3||x.length!=3||j.length!=3){return undefined}var r=m[0],q=m[1],p=m[2];var o=x[0],n=x[1],k=x[2];var w=j[0],v=j[1],u=j[2];if(r==o&&q==n&&p==k){return t}var i=r-o,h=q-n,g=p-k;var s=1/Math.sqrt(i*i+h*h+g*g);i*=s;h*=s;g*=s;var f=v*g-u*h;var e=u*i-w*g;var d=w*h-v*i;s=Math.sqrt(f*f+e*e+d*d);if(!s){f=0;e=0;d=0}else{s=1/Math.sqrt(f*f+e*e+d*d);f*=s;e*=s;d*=s}w=h*d-g*e;v=g*f-i*d;u=i*e-h*f;t[0]=f;t[1]=w;t[2]=i;t[3]=0;t[4]=e;t[5]=v;t[6]=h;t[7]=0;t[8]=d;t[9]=u;t[10]=g;t[11]=0;t[12]=-(f*r+e*q+d*p);t[13]=-(w*r+v*q+u*p);t[14]=-(i*r+h*q+g*p);t[15]=1;return t};c.prototype.perspectiveMatrix=function(f,e,h,g){var l=this.identity(this.create());var m=h*Math.tan(f*Math.PI/360);var d=m*e;var k=d*2,j=m*2,i=g-h;l[0]=h*2/k;l[1]=0;l[2]=0;l[3]=0;l[4]=0;l[5]=h*2/j;l[6]=0;l[7]=0;l[8]=0;l[9]=0;l[10]=-(g+h)/i;l[11]=-1;l[12]=0;l[13]=0;l[14]=-(g*h*2)/i;l[15]=0;return l};c.prototype.orthoMatrix=function(f,n,l,e,j,i){var o=this.identity(this.create());var g=(n-f);var m=(l-e);var k=(i-j);o[0]=2/g;o[1]=0;o[2]=0;o[3]=0;o[4]=0;o[5]=2/m;o[6]=0;o[7]=0;o[8]=0;o[9]=0;o[10]=-2/k;o[11]=0;o[12]=-(f+n)/g;o[13]=-(l+e)/m;o[14]=-(i+j)/k;o[15]=1;return o};c.prototype.transpose=function(e){var d=this.create();d[0]=e[0];d[1]=e[4];d[2]=e[8];d[3]=e[12];d[4]=e[1];d[5]=e[5];d[6]=e[9];d[7]=e[13];d[8]=e[2];d[9]=e[6];d[10]=e[10];d[11]=e[14];d[12]=e[3];d[13]=e[7];d[14]=e[11];d[15]=e[15];return d};return c}());a.WebGLMatrix=b})(EcognitaMathLib||(EcognitaMathLib={}));var EcognitaMathLib;(function(b){var a=(function(){function c(){}c.prototype.create=function(){return new Float32Array(4)};c.prototype.identity=function(d){d[0]=0;d[1]=0;d[2]=0;d[3]=1;return d};c.prototype.inverse=function(e){var d=this.create();d[0]=-e[0];d[1]=-e[1];d[2]=-e[2];d[3]=e[3];return d};c.prototype.normalize=function(i){var d=i[0],h=i[1],g=i[2],f=i[3];var e=Math.sqrt(d*d+h*h+g*g+f*f);if(e===0){i[0]=0;i[1]=0;i[2]=0;i[3]=0}else{e=1/e;i[0]=d*e;i[1]=h*e;i[2]=g*e;i[3]=f*e}return i};c.prototype.multiply=function(h,g){var e=this.create();var d=h[0],n=h[1],m=h[2],f=h[3];var k=g[0],j=g[1],i=g[2],l=g[3];e[0]=d*l+f*k+n*i-m*j;e[1]=n*l+f*j+m*k-d*i;e[2]=m*l+f*i+d*j-n*k;e[3]=f*l-d*k-n*j-m*i;return e};c.prototype.rotate=function(j,h){var i=Math.sqrt(h[0]*h[0]+h[1]*h[1]+h[2]*h[2]);if(!i){console.log("need a axis value");return undefined}var e=h[0],d=h[1],k=h[2];if(i!=1){i=1/i;e*=i;d*=i;k*=i}var g=Math.sin(j*0.5);var f=this.create();f[0]=e*g;f[1]=d*g;f[2]=k*g;f[3]=Math.cos(j*0.5);return f};c.prototype.ToV3=function(i,h){var g=new Array(3);var e=this.inverse(h);var f=this.create();f[0]=i[0];f[1]=i[1];f[2]=i[2];var d=this.multiply(e,f);var j=this.multiply(d,h);g[0]=j[0];g[1]=j[1];g[2]=j[2];return g};c.prototype.ToMat4x4=function(n){var p=new Float32Array(16);var j=n[0],i=n[1],h=n[2],k=n[3];var r=j+j,d=i+i,l=h+h;var g=j*r,f=j*d,e=j*l;var o=i*d,m=i*l,u=h*l;var v=k*r,t=k*d,s=k*l;p[0]=1-(o+u);p[1]=f-s;p[2]=e+t;p[3]=0;p[4]=f+s;p[5]=1-(g+u);p[6]=m-v;p[7]=0;p[8]=e-t;p[9]=m+v;p[10]=1-(g+o);p[11]=0;p[12]=0;p[13]=0;p[14]=0;p[15]=1;return p};c.prototype.slerp=function(g,f,e){if(e<0||e>1){console.log("parameter time's setting is wrong!");return undefined}var d=this.create();var k=g[0]*f[0]+g[1]*f[1]+g[2]*f[2]+g[3]*f[3];var l=1-k*k;if(l<=0){d[0]=g[0];d[1]=g[1];d[2]=g[2];d[3]=g[3]}else{l=Math.sqrt(l);if(Math.abs(l)<0.0001){d[0]=(g[0]*0.5+f[0]*0.5);d[1]=(g[1]*0.5+f[1]*0.5);d[2]=(g[2]*0.5+f[2]*0.5);d[3]=(g[3]*0.5+f[3]*0.5)}else{var i=Math.acos(k);var m=i*e;var j=Math.sin(i-m)/l;var h=Math.sin(m)/l;d[0]=g[0]*j+f[0]*h;d[1]=g[1]*j+f[1]*h;d[2]=g[2]*j+f[2]*h;d[3]=g[3]*j+f[3]*h}}return d};return c}());b.WebGLQuaternion=a})(EcognitaMathLib||(EcognitaMathLib={}));var Shaders={"toonShading-frag":"precision mediump float;\n\nuniform mat4      invMatrix;\nuniform vec3      lightDirection;\nuniform sampler2D texture;\nuniform vec4      edgeColor;\nvarying vec3      vNormal;\nvarying vec4      vColor;\n\nvoid main(void){\n	if(edgeColor.a > 0.0){\n		gl_FragColor   = edgeColor;\n	}else{\n		vec3  invLight = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n		float diffuse  = clamp(dot(vNormal, invLight), 0.1, 1.0);\n		vec4  smpColor = texture2D(texture, vec2(diffuse, 0.0));\n		gl_FragColor   = vColor * smpColor;\n	}\n}\n","shadowScreen-frag":"precision mediump float;\n\nuniform mat4      invMatrix;\nuniform vec3      lightPosition;\nuniform sampler2D texture;\nuniform bool      depthBuffer;\nvarying vec3      vPosition;\nvarying vec3      vNormal;\nvarying vec4      vColor;\nvarying vec4      vTexCoord;\nvarying vec4      vDepth;\n\nfloat restDepth(vec4 RGBA){\n    const float rMask = 1.0;\n    const float gMask = 1.0 / 255.0;\n    const float bMask = 1.0 / (255.0 * 255.0);\n    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n    float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));\n    return depth;\n}\n\nvoid main(void){\n    vec3  light     = lightPosition - vPosition;\n    vec3  invLight  = normalize(invMatrix * vec4(light, 0.0)).xyz;\n    float diffuse   = clamp(dot(vNormal, invLight), 0.1, 1.0);\n    float shadow    = restDepth(texture2DProj(texture, vTexCoord));\n    vec4 depthColor = vec4(1.0);\n    if(vDepth.w > 0.0){\n        if(depthBuffer){\n            vec4 lightCoord = vDepth / vDepth.w;\n            if(lightCoord.z - 0.0001 > shadow){\n                depthColor  = vec4(0.5, 0.5, 0.5, 1.0);\n            }\n        }else{\n            float near = 0.1;\n            float far  = 150.0;\n            float linerDepth = 1.0 / (far - near);\n            linerDepth *= length(vPosition.xyz - lightPosition);\n            if(linerDepth - 0.0001 > shadow){\n                depthColor  = vec4(0.5, 0.5, 0.5, 1.0);\n            }\n        }\n    }\n    gl_FragColor = vColor * (vec3(diffuse),1.0) * depthColor;\n}\n","bumpMapping-vert":"attribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nattribute vec2 textureCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 mvpMatrix;\nuniform   mat4 invMatrix;\nuniform   vec3 lightPosition;\nuniform   vec3 eyePosition;\nvarying   vec4 vColor;\nvarying   vec2 vTextureCoord;\nvarying   vec3 vEyeDirection;\nvarying   vec3 vLightDirection;\n\nvoid main(void){\n	vec3 pos      = (mMatrix * vec4(position, 0.0)).xyz;\n	vec3 invEye   = (invMatrix * vec4(eyePosition, 0.0)).xyz;\n	vec3 invLight = (invMatrix * vec4(lightPosition, 0.0)).xyz;\n	vec3 eye      = invEye - pos;\n	vec3 light    = invLight - pos;\n	vec3 n = normalize(normal);\n	vec3 t = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n	vec3 b = cross(n, t);\n	vEyeDirection.x   = dot(t, eye);\n	vEyeDirection.y   = dot(b, eye);\n	vEyeDirection.z   = dot(n, eye);\n	normalize(vEyeDirection);\n	vLightDirection.x = dot(t, light);\n	vLightDirection.y = dot(b, light);\n	vLightDirection.z = dot(n, light);\n	normalize(vLightDirection);\n	vColor         = color;\n	vTextureCoord  = textureCoord;\n	gl_Position    = mvpMatrix * vec4(position, 1.0);\n}\n","refractionMapping-frag":"precision mediump float;\n\nuniform vec3        eyePosition;\nuniform samplerCube cubeTexture;\nuniform bool        refraction;\nvarying vec3        vPosition;\nvarying vec3        vNormal;\nvarying vec4        vColor;\n\n//reflact calculation TODO\n//vec3 egt_refract(vec3 p, vec3 n,float eta){\n//}\n\nvoid main(void){\n	vec3 ref;\n	if(refraction){\n		ref = refract(normalize(vPosition - eyePosition), vNormal,0.6);\n	}else{\n		ref = vNormal;\n	}\n	vec4 envColor  = textureCube(cubeTexture, ref);\n	vec4 destColor = vColor * envColor;\n	gl_FragColor   = destColor;\n}\n","sobelFilter-frag":"precision mediump float;\n\nuniform sampler2D texture;\n\nuniform float hCoef[9];\nuniform float vCoef[9];\nvarying vec2 vTexCoord;\n\nconst float redScale   = 0.298912;\nconst float greenScale = 0.586611;\nconst float blueScale  = 0.114478;\nconst vec3  monochromeScale = vec3(redScale, greenScale, blueScale);\n\nvoid main(void){\n    vec2 offset[9];\n    offset[0] = vec2(-1.0, -1.0);\n    offset[1] = vec2( 0.0, -1.0);\n    offset[2] = vec2( 1.0, -1.0);\n    offset[3] = vec2(-1.0,  0.0);\n    offset[4] = vec2( 0.0,  0.0);\n    offset[5] = vec2( 1.0,  0.0);\n    offset[6] = vec2(-1.0,  1.0);\n    offset[7] = vec2( 0.0,  1.0);\n    offset[8] = vec2( 1.0,  1.0);\n    float tFrag = 1.0 / 512.0;\n    vec2  fc = vec2(gl_FragCoord.s, 512.0 - gl_FragCoord.t);\n    vec3  horizonColor = vec3(0.0);\n    vec3  verticalColor = vec3(0.0);\n    vec4  destColor = vec4(0.0);\n\n    horizonColor  += texture2D(texture, (fc + offset[0]) * tFrag).rgb * hCoef[0];\n    horizonColor  += texture2D(texture, (fc + offset[1]) * tFrag).rgb * hCoef[1];\n    horizonColor  += texture2D(texture, (fc + offset[2]) * tFrag).rgb * hCoef[2];\n    horizonColor  += texture2D(texture, (fc + offset[3]) * tFrag).rgb * hCoef[3];\n    horizonColor  += texture2D(texture, (fc + offset[4]) * tFrag).rgb * hCoef[4];\n    horizonColor  += texture2D(texture, (fc + offset[5]) * tFrag).rgb * hCoef[5];\n    horizonColor  += texture2D(texture, (fc + offset[6]) * tFrag).rgb * hCoef[6];\n    horizonColor  += texture2D(texture, (fc + offset[7]) * tFrag).rgb * hCoef[7];\n    horizonColor  += texture2D(texture, (fc + offset[8]) * tFrag).rgb * hCoef[8];\n\n    verticalColor += texture2D(texture, (fc + offset[0]) * tFrag).rgb * vCoef[0];\n    verticalColor += texture2D(texture, (fc + offset[1]) * tFrag).rgb * vCoef[1];\n    verticalColor += texture2D(texture, (fc + offset[2]) * tFrag).rgb * vCoef[2];\n    verticalColor += texture2D(texture, (fc + offset[3]) * tFrag).rgb * vCoef[3];\n    verticalColor += texture2D(texture, (fc + offset[4]) * tFrag).rgb * vCoef[4];\n    verticalColor += texture2D(texture, (fc + offset[5]) * tFrag).rgb * vCoef[5];\n    verticalColor += texture2D(texture, (fc + offset[6]) * tFrag).rgb * vCoef[6];\n    verticalColor += texture2D(texture, (fc + offset[7]) * tFrag).rgb * vCoef[7];\n    verticalColor += texture2D(texture, (fc + offset[8]) * tFrag).rgb * vCoef[8];\n\n    destColor = vec4(vec3(sqrt(horizonColor * horizonColor + verticalColor * verticalColor)), 1.0);\n    gl_FragColor = destColor;\n}\n","directionLighting-frag":"precision mediump float;\n\nvarying vec4 vColor;\n\nvoid main(void){\n	gl_FragColor = vColor;\n}\n","stencilBufferOutline-vert":"attribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nattribute vec2 textureCoord;\nuniform   mat4 mvpMatrix;\nuniform   mat4 invMatrix;\nuniform   vec3 lightDirection;\nuniform   bool useLight;\nuniform   bool outline;\nvarying   vec4 vColor;\nvarying   vec2 vTextureCoord;\n\nvoid main(void){\n	if(useLight){\n		vec3  invLight = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n		float diffuse  = clamp(dot(normal, invLight), 0.1, 1.0);\n		vColor         = color * vec4(vec3(diffuse), 1.0);\n	}else{\n		vColor         = color;\n	}\n	vTextureCoord      = textureCoord;\n	vec3 oPosition     = position;\n	if(outline){\n		oPosition     += normal * 0.1;\n	}\n	gl_Position = mvpMatrix * vec4(oPosition, 1.0);\n}\n","phong-frag":"precision mediump float;\n\nuniform mat4 invMatrix;\nuniform vec3 lightDirection;\nuniform vec3 eyeDirection;\nuniform vec4 ambientColor;\nvarying vec4 vColor;\nvarying vec3 vNormal;\n\nvoid main(void){\n	vec3 invLight = normalize(invMatrix*vec4(lightDirection,0.0)).xyz;\n	vec3 invEye = normalize(invMatrix*vec4(eyeDirection,0.0)).xyz;\n	vec3 halfLE = normalize(invLight+invEye);\n	float diffuse = clamp(dot(vNormal,invLight),0.0,1.0);\n	float specular = pow(clamp(dot(vNormal,halfLE),0.0,1.0),50.0);\n	vec4 destColor = vColor * vec4(vec3(diffuse),1.0) + vec4(vec3(specular),1.0) + ambientColor;\n	gl_FragColor = destColor;\n}\n","pointSprite-frag":"precision mediump float;\n\nuniform sampler2D texture;\nvarying vec4      vColor;\n\nvoid main(void){\n    vec4 smpColor = vec4(1.0);\n    smpColor = texture2D(texture,gl_PointCoord);\n    if(smpColor.a == 0.0){\n        discard;\n    }else{\n        gl_FragColor = vColor * smpColor;\n    }\n}\n","cubeTexBumpMapping-vert":"attribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nattribute vec2 textureCoord;\n\nuniform   mat4 mMatrix;\nuniform   mat4 mvpMatrix;\nvarying   vec3 vPosition;\nvarying   vec2 vTextureCoord;\nvarying   vec3 vNormal;\nvarying   vec4 vColor;\nvarying   vec3 tTangent;\n\nvoid main(void){\n	vPosition   = (mMatrix * vec4(position, 1.0)).xyz;\n	vNormal     = (mMatrix * vec4(normal, 0.0)).xyz;\n	vTextureCoord = textureCoord;\n	vColor      = color;\n	tTangent      = cross(vNormal, vec3(0.0, 1.0, 0.0));\n	gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","point-frag":"precision mediump float;\nvarying vec4      vColor;\n\nvoid main(void){\n    gl_FragColor = vColor;\n}\n","sepiaFilter-frag":"precision mediump float;\n\nuniform sampler2D texture;\nuniform bool      sepia;\nvarying vec2      vTexCoord;\n\nconst float redScale   = 0.298912;\nconst float greenScale = 0.586611;\nconst float blueScale  = 0.114478;\nconst vec3  monochromeScale = vec3(redScale, greenScale, blueScale);\n\nconst float sRedScale   = 1.07;\nconst float sGreenScale = 0.74;\nconst float sBlueScale  = 0.43;\nconst vec3  sepiaScale = vec3(sRedScale, sGreenScale, sBlueScale);\n\nvoid main(void){\n    vec4  smpColor  = texture2D(texture, vTexCoord);\n    float grayColor = dot(smpColor.rgb, monochromeScale);\n\n    vec3 monoColor = vec3(grayColor) * sepiaScale; \n    smpColor = vec4(monoColor, 1.0);\n\n    gl_FragColor = smpColor;\n}\n","texture-vert":"attribute vec3 position;\nattribute vec4 color;\nattribute vec2 textureCoord;\nuniform   mat4 mvpMatrix;\nvarying   vec4 vColor;\nvarying   vec2 vTextureCoord;\n\nvoid main(void){\n    vColor        = color;\n    vTextureCoord = textureCoord;\n    gl_Position   = mvpMatrix * vec4(position, 1.0);\n}\n","specular-vert":"attribute vec3 position;\nattribute vec4 color;\nattribute vec3 normal;\n\nuniform mat4 mvpMatrix;\nuniform mat4 invMatrix;\n\nuniform vec3 lightDirection;\nuniform vec3 eyeDirection;\nuniform vec4 ambientColor;\nvarying vec4 vColor;\n\nvoid main(void){\n    vec3 invLight = normalize(invMatrix*vec4(lightDirection,0.0)).xyz;\n    vec3 invEye = normalize(invMatrix* vec4(eyeDirection,0.0)).xyz;\n    vec3 halfLE = normalize(invLight+invEye);\n\n    float diffuse = clamp(dot(invLight,normal),0.0,1.0);\n    float specular = pow(clamp(dot(normal,halfLE),0.0,1.0),50.0);\n    vec4 light = color*vec4(vec3(diffuse),1.0)+vec4(vec3(specular),1.0);\n    vColor = light + ambientColor;\n    gl_Position    = mvpMatrix * vec4(position, 1.0);\n}\n","projTexture-frag":"precision mediump float;\n\nuniform mat4      invMatrix;\nuniform vec3      lightPosition;\nuniform sampler2D texture;\nvarying vec3      vPosition;\nvarying vec3      vNormal;\nvarying vec4      vColor;\nvarying vec4      vTexCoord;\n\nvoid main(void){\n	vec3  light    = lightPosition - vPosition;\n	vec3  invLight = normalize(invMatrix * vec4(light, 0.0)).xyz;\n	float diffuse  = clamp(dot(vNormal, invLight), 0.1, 1.0);\n	vec4  smpColor = texture2DProj(texture, vTexCoord);\n	gl_FragColor   = vColor * (0.5 + diffuse) * smpColor;\n}\n","filterScene-vert":"attribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mvpMatrix;\nuniform   mat4 invMatrix;\nuniform   vec3 lightDirection;\nuniform   vec3 eyeDirection;\nuniform   vec4 ambientColor;\nvarying   vec4 vColor;\n\nvoid main(void){\n	vec3  invLight = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n	vec3  invEye   = normalize(invMatrix * vec4(eyeDirection, 0.0)).xyz;\n	vec3  halfLE   = normalize(invLight + invEye);\n	float diffuse  = clamp(dot(normal, invLight), 0.0, 1.0);\n	float specular = pow(clamp(dot(normal, halfLE), 0.0, 1.0), 50.0);\n	vec4  amb      = color * ambientColor;\n	vColor         = amb * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0);\n	gl_Position    = mvpMatrix * vec4(position, 1.0);\n}\n","blurEffect-frag":"precision mediump float;\n\nuniform sampler2D texture;\nvarying vec4      vColor;\n\nvoid main(void){\n	vec2 tFrag = vec2(1.0 / 512.0);\n	vec4 destColor = texture2D(texture, gl_FragCoord.st * tFrag);\n	destColor *= 0.36;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2(-1.0,  1.0)) * tFrag) * 0.04;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 0.0,  1.0)) * tFrag) * 0.04;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 1.0,  1.0)) * tFrag) * 0.04;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2(-1.0,  0.0)) * tFrag) * 0.04;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 1.0,  0.0)) * tFrag) * 0.04;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2(-1.0, -1.0)) * tFrag) * 0.04;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 0.0, -1.0)) * tFrag) * 0.04;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 1.0, -1.0)) * tFrag) * 0.04;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2(-2.0,  2.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2(-1.0,  2.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 0.0,  2.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 1.0,  2.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 2.0,  2.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2(-2.0,  1.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 2.0,  1.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2(-2.0,  0.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 2.0,  0.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2(-2.0, -1.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 2.0, -1.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2(-2.0, -2.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2(-1.0, -2.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 0.0, -2.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 1.0, -2.0)) * tFrag) * 0.02;\n	destColor += texture2D(texture, (gl_FragCoord.st + vec2( 2.0, -2.0)) * tFrag) * 0.02;\n\n	gl_FragColor = vColor * destColor;\n}\n","laplacianFilter-vert":"attribute vec3 position;\nattribute vec2 texCoord;\nuniform   mat4 mvpMatrix;\nvarying   vec2 vTexCoord;\n\nvoid main(void){\n	vTexCoord   = texCoord;\n	gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","pointLighting-frag":"precision mediump float;\n\nuniform mat4 invMatrix;\nuniform vec3 lightPosition;\nuniform vec3 eyeDirection;\nuniform vec4 ambientColor;\n\nvarying vec4 vColor;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nvoid main(void){\n	vec3 lightVec = lightPosition -vPosition;\n	vec3 invLight = normalize(invMatrix*vec4(lightVec,0.0)).xyz;\n	vec3 invEye = normalize(invMatrix*vec4(eyeDirection,0.0)).xyz;\n	vec3 halfLE = normalize(invLight+invEye);\n	float diffuse = clamp(dot(vNormal,invLight),0.0,1.0);\n	float specular = pow(clamp(dot(vNormal,halfLE),0.0,1.0),50.0);\n	vec4 destColor = vColor * vec4(vec3(diffuse),1.0) + vec4(vec3(specular),1.0) + ambientColor;\n	gl_FragColor = destColor;\n}\n","grayScaleFilter-vert":"attribute vec3 position;\nattribute vec2 texCoord;\nuniform   mat4 mvpMatrix;\nvarying   vec2 vTexCoord;\n\nvoid main(void){\n	vTexCoord   = texCoord;\n	gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","frameBuffer-vert":"attribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nattribute vec2 textureCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 mvpMatrix;\nuniform   mat4 invMatrix;\nuniform   vec3 lightDirection;\nuniform   bool useLight;\nvarying   vec4 vColor;\nvarying   vec2 vTextureCoord;\n\nvoid main(void){\n	if(useLight){\n		vec3  invLight = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n		float diffuse  = clamp(dot(normal, invLight), 0.2, 1.0);\n		vColor         = vec4(color.xyz * vec3(diffuse), 1.0);\n	}else{\n		vColor         = color;\n	}\n	vTextureCoord  = textureCoord;\n	gl_Position    = mvpMatrix * vec4(position, 1.0);\n}\n","cubeTexMapping-frag":"precision mediump float;\n\nuniform vec3        eyePosition;\nuniform samplerCube cubeTexture;\nuniform bool        reflection;\nvarying vec3        vPosition;\nvarying vec3        vNormal;\nvarying vec4        vColor;\n\n//reflect = I - 2.0 * dot(N, I) * N.\nvec3 egt_reflect(vec3 p, vec3 n){\n  return  p - 2.0* dot(n,p) * n;\n}\n\nvoid main(void){\n	vec3 ref;\n	if(reflection){\n		ref = reflect(vPosition - eyePosition, vNormal);\n        //ref = egt_reflect(normalize(vPosition - eyePosition),normalize(vNormal));\n	}else{\n		ref = vNormal;\n	}\n	vec4 envColor  = textureCube(cubeTexture, ref);\n	vec4 destColor = vColor * envColor;\n	gl_FragColor   = destColor;\n}\n","shadowDepthBuffer-vert":"attribute vec3 position;\nuniform mat4 mvpMatrix;\n\nvarying vec4 vPosition;\n\nvoid main(void){\n    vPosition = mvpMatrix * vec4(position, 1.0);\n    gl_Position = vPosition;\n}\n","demo1-vert":"attribute vec3 position;\nattribute vec4 color;\nuniform   mat4 mvpMatrix;\nvarying vec4 vColor;\n\nvoid main(void){\n	vColor = color;\n	gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","demo-frag":"void main(void){\n	gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n","dir_ambient-vert":"attribute vec3 position;\nattribute vec4 color;\nattribute vec3 normal;\n\nuniform mat4 mvpMatrix;\nuniform mat4 invMatrix;\nuniform vec3 lightDirection;\nuniform vec4 ambientColor;\nvarying vec4 vColor;\n\nvoid main(void){\n    vec3 invLight = normalize(invMatrix*vec4(lightDirection,0)).xyz;\n    float diffuse = clamp(dot(invLight,normal),0.1,1.0);\n    vColor = color*vec4(vec3(diffuse),1.0) +ambientColor;\n    gl_Position    = mvpMatrix * vec4(position, 1.0);\n}\n","point-vert":"attribute vec3 position;\nattribute vec4 color;\nuniform   mat4 mvpMatrix;\nuniform   float pointSize;\nvarying   vec4 vColor;\n\nvoid main(void){\n    vColor        = color;\n    gl_Position   = mvpMatrix * vec4(position, 1.0);\n    gl_PointSize  = pointSize;\n}\n","sepiaFilter-vert":"attribute vec3 position;\nattribute vec2 texCoord;\nuniform   mat4 mvpMatrix;\nvarying   vec2 vTexCoord;\n\nvoid main(void){\n	vTexCoord   = texCoord;\n	gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","texture-frag":"precision mediump float;\n\nuniform sampler2D texture;\nvarying vec4      vColor;\nvarying vec2      vTextureCoord;\n\nvoid main(void){\n    vec4 smpColor = texture2D(texture, vTextureCoord);\n    gl_FragColor  = vColor * smpColor;\n}\n","projTexture-vert":"attribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 tMatrix;\nuniform   mat4 mvpMatrix;\nvarying   vec3 vPosition;\nvarying   vec3 vNormal;\nvarying   vec4 vColor;\nvarying   vec4 vTexCoord;\n\nvoid main(void){\n	vPosition   = (mMatrix * vec4(position, 1.0)).xyz;\n	vNormal     = normal;\n	vColor      = color;\n	vTexCoord   = tMatrix * vec4(vPosition, 1.0);\n	gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","specular-frag":"precision mediump float;\n\nvarying vec4 vColor;\n\nvoid main(void){\n	gl_FragColor = vColor;\n}\n","blurEffect-vert":"attribute vec3 position;\nattribute vec4 color;\nuniform   mat4 mvpMatrix;\nvarying   vec4 vColor;\n\nvoid main(void){\n	vColor      = color;\n	gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","filterScene-frag":"precision mediump float;\n\nvarying vec4 vColor;\n\nvoid main(void){\n	gl_FragColor = vColor;\n}\n","laplacianFilter-frag":"precision mediump float;\n\nuniform sampler2D texture;\n\nuniform float coef[9];\nvarying vec2 vTexCoord;\n\nconst float redScale   = 0.298912;\nconst float greenScale = 0.586611;\nconst float blueScale  = 0.114478;\nconst vec3  monochromeScale = vec3(redScale, greenScale, blueScale);\n\nvoid main(void){\n    vec2 offset[9];\n    offset[0] = vec2(-1.0, -1.0);\n    offset[1] = vec2( 0.0, -1.0);\n    offset[2] = vec2( 1.0, -1.0);\n    offset[3] = vec2(-1.0,  0.0);\n    offset[4] = vec2( 0.0,  0.0);\n    offset[5] = vec2( 1.0,  0.0);\n    offset[6] = vec2(-1.0,  1.0);\n    offset[7] = vec2( 0.0,  1.0);\n    offset[8] = vec2( 1.0,  1.0);\n    float tFrag = 1.0 / 512.0;\n    vec2  fc = vec2(gl_FragCoord.s, 512.0 - gl_FragCoord.t);\n    vec3  destColor = vec3(0.0);\n\n    destColor  += texture2D(texture, (fc + offset[0]) * tFrag).rgb * coef[0];\n    destColor  += texture2D(texture, (fc + offset[1]) * tFrag).rgb * coef[1];\n    destColor  += texture2D(texture, (fc + offset[2]) * tFrag).rgb * coef[2];\n    destColor  += texture2D(texture, (fc + offset[3]) * tFrag).rgb * coef[3];\n    destColor  += texture2D(texture, (fc + offset[4]) * tFrag).rgb * coef[4];\n    destColor  += texture2D(texture, (fc + offset[5]) * tFrag).rgb * coef[5];\n    destColor  += texture2D(texture, (fc + offset[6]) * tFrag).rgb * coef[6];\n    destColor  += texture2D(texture, (fc + offset[7]) * tFrag).rgb * coef[7];\n    destColor  += texture2D(texture, (fc + offset[8]) * tFrag).rgb * coef[8];\n\n    destColor =max(destColor, 0.0);\n    gl_FragColor = vec4(destColor, 1.0);\n}\n","grayScaleFilter-frag":"precision mediump float;\n\nuniform sampler2D texture;\nuniform bool      grayScale;\nvarying vec2      vTexCoord;\n\nconst float redScale   = 0.298912;\nconst float greenScale = 0.586611;\nconst float blueScale  = 0.114478;\nconst vec3  monochromeScale = vec3(redScale, greenScale, blueScale);\n\nvoid main(void){\n	vec4 smpColor = texture2D(texture, vTexCoord);\n	if(grayScale){\n		float grayColor = dot(smpColor.rgb, monochromeScale);\n		smpColor = vec4(vec3(grayColor), 1.0);\n	}\n	gl_FragColor = smpColor;\n}\n","pointLighting-vert":"attribute vec3 position;\nattribute vec4 color;\nattribute vec3 normal;\n\nuniform mat4 mvpMatrix;\nuniform mat4 mMatrix;\n\nvarying vec3 vPosition;\nvarying vec4 vColor;\nvarying vec3 vNormal;\n\nvoid main(void){\n    vPosition = (mMatrix*vec4(position,1.0)).xyz;\n    vNormal = normal;\n    vColor = color;\n    gl_Position    = mvpMatrix * vec4(position, 1.0);\n}\n","cubeTexMapping-vert":"attribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 mvpMatrix;\nvarying   vec3 vPosition;\nvarying   vec3 vNormal;\nvarying   vec4 vColor;\n\nvoid main(void){\n	vPosition   = (mMatrix * vec4(position, 1.0)).xyz;\n	vNormal     = (mMatrix * vec4(normal, 0.0)).xyz;\n	vColor      = color;\n	gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","shadowDepthBuffer-frag":"precision mediump float;\n\nuniform bool depthBuffer;\n\nvarying vec4 vPosition;\n\nvec4 convRGBA(float depth){\n    float r = depth;\n    float g = fract(r*255.0);\n    float b = fract(g*255.0); \n    float a = fract(b*255.0);\n    float coef = 1.0/255.0;\n    r-= g* coef; \n    g-= b* coef; \n    b-= a* coef; \n    return vec4(r,g,b,a);\n}\n\nvoid main(void){\n    vec4 convColor;\n    if(depthBuffer){\n        convColor = convRGBA(gl_FragCoord.z);\n    }else{\n        float near = 0.1;\n        float far  = 150.0;\n        float linerDepth = 1.0 / (far - near);\n        linerDepth *= length(vPosition);\n        convColor = convRGBA(linerDepth);\n    }\n    gl_FragColor = convColor;\n}\n","frameBuffer-frag":"precision mediump float;\n\nuniform sampler2D texture;\nvarying vec4      vColor;\nvarying vec2      vTextureCoord;\n\nvoid main(void){\n	vec4 smpColor = texture2D(texture, vTextureCoord);\n	gl_FragColor  = vColor * smpColor;\n}\n","demo1-frag":"precision mediump float;\nvarying vec4 vColor;\n\nvoid main(void){\n	gl_FragColor = vColor;\n}\n","demo-vert":"attribute vec3 position;\nuniform   mat4 mvpMatrix;\n\nvoid main(void){\n	gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","dir_ambient-frag":"precision mediump float;\n\nvarying vec4 vColor;\n\nvoid main(void){\n	gl_FragColor = vColor;\n}\n","bumpMapping-frag":"precision mediump float;\n\nuniform sampler2D texture;\nvarying vec4      vColor;\nvarying vec2      vTextureCoord;\nvarying vec3      vEyeDirection;\nvarying vec3      vLightDirection;\n\nvoid main(void){\n	vec3 mNormal    = (texture2D(texture, vTextureCoord) * 2.0 - 1.0).rgb;\n	vec3 light      = normalize(vLightDirection);\n	vec3 eye        = normalize(vEyeDirection);\n	vec3 halfLE     = normalize(light + eye);\n	float diffuse   = clamp(dot(mNormal, light), 0.1, 1.0);\n	float specular  = pow(clamp(dot(mNormal, halfLE), 0.0, 1.0), 50.0);\n	vec4  destColor = vColor * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0);\n	gl_FragColor    = destColor;\n}\n","toonShading-vert":"attribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mvpMatrix;\nuniform   bool edge;\nvarying   vec3 vNormal;\nvarying   vec4 vColor;\n\nvoid main(void){\n	vec3 pos    = position;\n	if(edge){\n		pos    += normal * 0.05;\n	}\n	vNormal     = normal;\n	vColor      = color;\n	gl_Position = mvpMatrix * vec4(pos, 1.0);\n}\n","shadowScreen-vert":"attribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 mvpMatrix;\nuniform   mat4 tMatrix;\nuniform   mat4 lgtMatrix;\nvarying   vec3 vPosition;\nvarying   vec3 vNormal;\nvarying   vec4 vColor;\nvarying   vec4 vTexCoord;\nvarying   vec4 vDepth;\n\nvoid main(void){\n    vPosition   = (mMatrix * vec4(position, 1.0)).xyz;\n    vNormal     = normal;\n    vColor      = color;\n    vTexCoord   = tMatrix * vec4(vPosition, 1.0);\n    vDepth      = lgtMatrix * vec4(position, 1.0);\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","refractionMapping-vert":"attribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 mvpMatrix;\nvarying   vec3 vPosition;\nvarying   vec3 vNormal;\nvarying   vec4 vColor;\n\nvoid main(void){\n	vPosition   = (mMatrix * vec4(position, 1.0)).xyz;\n	vNormal     = normalize((mMatrix * vec4(normal, 0.0)).xyz);\n	vColor      = color;\n	gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n","directionLighting-vert":"attribute vec3 position;\nattribute vec4 color;\nattribute vec3 normal;\n\nuniform mat4 mvpMatrix;\nuniform mat4 invMatrix;\nuniform vec3 lightDirection;\nvarying vec4 vColor;\n\nvoid main(void){\n    vec3 invLight = normalize(invMatrix*vec4(lightDirection,0)).xyz;\n    float diffuse = clamp(dot(invLight,normal),0.1,1.0);\n    vColor = color*vec4(vec3(diffuse),1.0);\n    gl_Position    = mvpMatrix * vec4(position, 1.0);\n}\n","phong-vert":"attribute vec3 position;\nattribute vec4 color;\nattribute vec3 normal;\n\nuniform mat4 mvpMatrix;\n\nvarying vec4 vColor;\nvarying vec3 vNormal;\n\nvoid main(void){\n    vNormal = normal;\n    vColor = color;\n    gl_Position    = mvpMatrix * vec4(position, 1.0);\n}\n","stencilBufferOutline-frag":"precision mediump float;\n\nuniform sampler2D texture;\nuniform bool      useTexture;\nvarying vec4      vColor;\nvarying vec2      vTextureCoord;\n\nvoid main(void){\n	vec4 smpColor = vec4(1.0);\n	if(useTexture){\n		smpColor = texture2D(texture, vTextureCoord);\n	}\n	gl_FragColor = vColor * smpColor;\n}\n","pointSprite-vert":"attribute vec3 position;\nattribute vec4 color;\nuniform   mat4 mvpMatrix;\nuniform   float pointSize;\nvarying   vec4 vColor;\n\nvoid main(void){\n    vColor        = color;\n    gl_Position   = mvpMatrix * vec4(position, 1.0);\n    gl_PointSize  = pointSize;\n}\n","cubeTexBumpMapping-frag":"precision mediump float;\n\nuniform vec3        eyePosition;\nuniform sampler2D   normalMap;\nuniform samplerCube cubeTexture;\nuniform bool        reflection;\nvarying vec3        vPosition;\nvarying vec2        vTextureCoord;\nvarying vec3        vNormal;\nvarying vec3        tTangent;\n\nvarying vec4        vColor;\n\n//reflect = I - 2.0 * dot(N, I) * N.\nvec3 egt_reflect(vec3 p, vec3 n){\n  return  p - 2.0* dot(n,p) * n;\n}\n\nvoid main(void){\n	vec3 tBinormal = cross(vNormal, tTangent);\n	mat3 mView     = mat3(tTangent, tBinormal, vNormal);\n	vec3 mNormal   = mView * (texture2D(normalMap, vTextureCoord) * 2.0 - 1.0).rgb;\n	vec3 ref;\n	if(reflection){\n		ref = reflect(vPosition - eyePosition, mNormal);\n        //ref = egt_reflect(normalize(vPosition - eyePosition),normalize(vNormal));\n	}else{\n		ref = vNormal;\n	}\n	vec4 envColor  = textureCube(cubeTexture, ref);\n	vec4 destColor = vColor * envColor;\n	gl_FragColor   = destColor;\n}\n"};var EcognitaMathLib;(function(c){var e=(function(){function f(m,q,n,k,p){if(m===void 0){m=undefined}if(q===void 0){q=undefined}if(n===void 0){n=true}if(k===void 0){k=true}if(p===void 0){p=false}this.data=new Array();var l=[-1,0,-1,1,0,-1,-1,0,1,1,0,1];var o=[0,1,0,0,1,0,0,1,0,0,1,0];this.index=[0,1,2,3,2,1];var g=[0,0,1,0,0,1,1,1];for(var j=0;j<4;j++){if(m==undefined){this.data.push(l[j*3+0],l[j*3+1],l[j*3+2])}else{this.data.push(m[j*3+0],m[j*3+1],m[j*3+2])}if(n){this.data.push(o[j*3+0],o[j*3+1],o[j*3+2])}if(q==undefined){var h=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];if(k){this.data.push(h[j*4+0],h[j*4+1],h[j*4+2],h[j*4+3])}}else{if(k){this.data.push(q[j*4+0],q[j*4+1],q[j*4+2],q[j*4+3])}}if(p){this.data.push(g[j*2+0],g[j*2+1])}}}return f}());c.BoardModel=e;var a=(function(){function f(h,m,g,l,j,i,k){if(k===void 0){k=false}this.verCrossSectionSmooth=h;this.horCrossSectionSmooth=m;this.verRadius=g;this.horRadius=l;this.data=new Array();this.index=new Array();this.normal=new Array();this.preCalculate(j,i,k)}f.prototype.preCalculate=function(l,s,k){if(k===void 0){k=false}for(var o=0;o<=this.verCrossSectionSmooth;o++){var v=Math.PI*2/this.verCrossSectionSmooth*o;var u=Math.cos(v);var t=Math.sin(v);for(var x=0;x<=this.horCrossSectionSmooth;x++){var w=Math.PI*2/this.horCrossSectionSmooth*x;var r=(u*this.verRadius+this.horRadius)*Math.cos(w);var p=t*this.verRadius;var n=(u*this.verRadius+this.horRadius)*Math.sin(w);this.data.push(r,p,n);if(s){var q=u*Math.cos(w);var m=u*Math.sin(w);this.normal.push(q,t,m);this.data.push(q,t,m)}if(l==undefined){var j=c.HSV2RGB(360/this.horCrossSectionSmooth*x,1,1,1);this.data.push(j[0],j[1],j[2],j[3])}else{this.data.push(l[0],l[1],l[2],l[3])}if(k){var h=1/this.horCrossSectionSmooth*x;var g=1/this.verCrossSectionSmooth*o+0.5;if(g>1){g-=1}g=1-g;this.data.push(h,g)}}}for(o=0;o<this.verCrossSectionSmooth;o++){for(x=0;x<this.horCrossSectionSmooth;x++){v=(this.horCrossSectionSmooth+1)*o+x;this.index.push(v,v+this.horCrossSectionSmooth+1,v+1);this.index.push(v+this.horCrossSectionSmooth+1,v+this.horCrossSectionSmooth+2,v+1)}}};return f}());c.TorusModel=a;var b=(function(){function f(h,l,g,j,i,k){if(k===void 0){k=false}this.verCrossSectionSmooth=h;this.horCrossSectionSmooth=l;this.Radius=g;this.data=new Array();this.index=new Array();this.preCalculate(j,i,k)}f.prototype.preCalculate=function(j,q,h){if(h===void 0){h=false}for(var m=0;m<=this.verCrossSectionSmooth;m++){var t=Math.PI/this.verCrossSectionSmooth*m;var s=Math.cos(t);var r=Math.sin(t);for(var v=0;v<=this.horCrossSectionSmooth;v++){var u=Math.PI*2/this.horCrossSectionSmooth*v;var p=r*this.Radius*Math.cos(u);var n=s*this.Radius;var l=r*this.Radius*Math.sin(u);this.data.push(p,n,l);if(q){var o=r*Math.cos(u);var k=r*Math.sin(u);this.data.push(o,s,k)}if(j==undefined){var g=c.HSV2RGB(360/this.horCrossSectionSmooth*m,1,1,1);this.data.push(g[0],g[1],g[2],g[3])}else{this.data.push(j[0],j[1],j[2],j[3])}if(h){this.data.push(1-1/this.horCrossSectionSmooth*v,1/this.verCrossSectionSmooth*m)}}}for(m=0;m<this.verCrossSectionSmooth;m++){for(v=0;v<this.horCrossSectionSmooth;v++){t=(this.horCrossSectionSmooth+1)*m+v;this.index.push(t,t+1,t+this.horCrossSectionSmooth+2);this.index.push(t,t+this.horCrossSectionSmooth+2,t+this.horCrossSectionSmooth+1)}}};return f}());c.ShpereModel=b;var d=(function(){function f(p,l,n,k){if(k===void 0){k=false}this.side=p;this.data=new Array();this.index=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];var r=p*0.5;var q=[-r,-r,r,r,-r,r,r,r,r,-r,r,r,-r,-r,-r,-r,r,-r,r,r,-r,r,-r,-r,-r,r,-r,-r,r,r,r,r,r,r,r,-r,-r,-r,-r,r,-r,-r,r,-r,r,-r,-r,r,r,-r,-r,r,r,-r,r,r,r,r,-r,r,-r,-r,-r,-r,-r,r,-r,r,r,-r,r,-r];var o=[-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1];var h=new Array();for(var m=0;m<q.length/3;m++){if(l!=undefined){var j=l}else{j=c.HSV2RGB(360/q.length/3*m,1,1,1)}h.push(j[0],j[1],j[2],j[3])}var s=[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1];var g=24;for(var m=0;m<g;m++){this.data.push(q[m*3+0],q[m*3+1],q[m*3+2]);if(n){this.data.push(o[m*3+0],o[m*3+1],o[m*3+2])}this.data.push(h[m*4+0],h[m*4+1],h[m*4+2],h[m*4+3]);if(k){this.data.push(s[m*2+0],s[m*2+1])}}}return f}());c.CubeModel=d})(EcognitaMathLib||(EcognitaMathLib={}));var EcognitaMathLib;(function(e){function i(j){switch(j){case gl.BYTE:case gl.UNSIGNED_BYTE:return 1;case gl.SHORT:case gl.UNSIGNED_SHORT:return 2;case gl.INT:case gl.UNSIGNED_INT:case gl.FLOAT:return 4;default:return 0}}e.GetGLTypeSize=i;var d=(function(){function j(l,k,m,n){if(n===void 0){n=gl.REPEAT}this.type=k?gl.FLOAT:gl.UNSIGNED_BYTE;this.format=[gl.LUMINANCE,gl.RG,gl.RGB,gl.RGBA][l-1];this.glName=gl.createTexture();this.bind(this.glName);gl.texImage2D(gl.TEXTURE_2D,0,this.format,this.format,this.type,m);gl.generateMipmap(gl.TEXTURE_2D);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,n);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,n);this.texture=this.glName;this.bind(null)}j.prototype.bind=function(k){gl.bindTexture(gl.TEXTURE_2D,k)};return j}());e.WebGL_Texture=d;var h=(function(){function j(k){this.cubeSource=k;this.cubeTarget=new Array(gl.TEXTURE_CUBE_MAP_POSITIVE_X,gl.TEXTURE_CUBE_MAP_POSITIVE_Y,gl.TEXTURE_CUBE_MAP_POSITIVE_Z,gl.TEXTURE_CUBE_MAP_NEGATIVE_X,gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,gl.TEXTURE_CUBE_MAP_NEGATIVE_Z);this.loadCubeTexture();this.cubeTexture=undefined}j.prototype.loadCubeTexture=function(){var n=this;var k=new Array();var m=0;this.cubeImage=k;for(var l=0;l<this.cubeSource.length;l++){k[l]=new Object();k[l].data=new Image();k[l].data.src=this.cubeSource[l];k[l].data.onload=(function(){m++;if(m==n.cubeSource.length){n.generateCubeMap()}})}};j.prototype.generateCubeMap=function(){var k=gl.createTexture();gl.bindTexture(gl.TEXTURE_CUBE_MAP,k);for(var l=0;l<this.cubeSource.length;l++){gl.texImage2D(this.cubeTarget[l],0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,this.cubeImage[l].data)}gl.generateMipmap(gl.TEXTURE_CUBE_MAP);gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MIN_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MAG_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);this.cubeTexture=k;gl.bindTexture(gl.TEXTURE_CUBE_MAP,null)};return j}());e.WebGL_CubeMapTexture=h;var c=(function(){function j(){this.glName=gl.createFramebuffer()}j.prototype.bind=function(){gl.bindFramebuffer(gl.FRAMEBUFFER,this.glName)};j.prototype.unbind=function(){gl.bindFramebuffer(gl.FRAMEBUFFER,null)};j.prototype.attachTexture=function(l,k){gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0+k,gl.TEXTURE_2D,l.glName,0)};j.prototype.detachTexture=function(k){gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0+k,gl.TEXTURE_2D,null,0)};j.prototype.drawBuffers=function(m){var k=[];for(var l=0;l<m;++l){k.push(gl.COLOR_ATTACHMENT0+l)}multiBufExt.drawBuffersWEBGL(k)};return j}());e.WebGL_RenderTarget=c;var b=(function(){function j(l,k,m){this.vertex=this.createShaderObject(l,k,false);this.fragment=this.createShaderObject(l,m,true);this.program=gl.createProgram();gl.attachShader(this.program,this.vertex);gl.attachShader(this.program,this.fragment);gl.linkProgram(this.program);this.uniforms={};if(!gl.getProgramParameter(this.program,gl.LINK_STATUS)){alert("Could not initialise shaders")}}j.prototype.bind=function(){gl.useProgram(this.program)};j.prototype.createShaderObject=function(m,l,q){var p=this.resolveShaderSource(m,l);var o=gl.createShader(q?gl.FRAGMENT_SHADER:gl.VERTEX_SHADER);gl.shaderSource(o,p);gl.compileShader(o);if(!gl.getShaderParameter(o,gl.COMPILE_STATUS)){var k=p.split("\n");for(var n=0;n<k.length;++n){k[n]=("   "+(n+1)).slice(-4)+" | "+k[n]}p=k.join("\n");throw new Error((q?"Fragment":"Vertex")+" shader compilation error for shader '"+l+"':\n\n    "+gl.getShaderInfoLog(o).split("\n").join("\n    ")+"\nThe expanded shader source code was:\n\n"+p)}return o};j.prototype.resolveShaderSource=function(m,l){if(!(l in m)){throw new Error("Unable to find shader source for '"+l+"'")}var o=m[l];var n=new RegExp('#include "(.+)"');var k;while(k=n.exec(o)){o=o.slice(0,k.index)+this.resolveShaderSource(m,k[1])+o.slice(k.index+k[0].length)}return o};j.prototype.uniformIndex=function(k){if(!(k in this.uniforms)){this.uniforms[k]=gl.getUniformLocation(this.program,k)}return this.uniforms[k]};j.prototype.uniformTexture=function(k,l){var m=this.uniformIndex(k);if(m!=-1){gl.uniform1i(m,l.boundUnit)}};j.prototype.uniformF=function(k,l){var m=this.uniformIndex(k);if(m!=-1){gl.uniform1f(m,l)}};j.prototype.uniform2F=function(l,k,n){var m=this.uniformIndex(l);if(m!=-1){gl.uniform2f(m,k,n)}};return j}());e.WebGL_Shader=b;var g=(function(){function j(){this.attributes=[];this.elementSize=0}j.prototype.bind=function(m){gl.bindBuffer(gl.ARRAY_BUFFER,this.glName);for(var l=0;l<this.attributes.length;++l){this.attributes[l].index=gl.getAttribLocation(m.program,this.attributes[l].name);if(this.attributes[l].index>=0){var k=this.attributes[l];gl.enableVertexAttribArray(k.index);gl.vertexAttribPointer(k.index,k.size,k.type,k.norm,this.elementSize,k.offset)}}};j.prototype.release=function(){for(var k=0;k<this.attributes.length;++k){if(this.attributes[k].index>=0){gl.disableVertexAttribArray(this.attributes[k].index);this.attributes[k].index=-1}}};j.prototype.addAttribute=function(k,m,n,l){this.attributes.push({name:k,size:m,type:n,norm:l,offset:this.elementSize,index:-1});this.elementSize+=m*i(n)};j.prototype.addAttributes=function(k,l){for(var m=0;m<k.length;m++){this.addAttribute(k[m],l[m],gl.FLOAT,false)}};j.prototype.init=function(k){this.length=k;this.glName=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,this.glName);gl.bufferData(gl.ARRAY_BUFFER,this.length*this.elementSize,gl.STATIC_DRAW)};j.prototype.copy=function(k){k=new Float32Array(k);if(k.byteLength!=this.length*this.elementSize){throw new Error("Resizing VBO during copy strongly discouraged")}gl.bufferData(gl.ARRAY_BUFFER,k,gl.STATIC_DRAW);gl.bindBuffer(gl.ARRAY_BUFFER,null)};j.prototype.draw=function(l,k){gl.drawArrays(l,0,k?k:this.length)};return j}());e.WebGL_VertexBuffer=g;var a=(function(){function j(){}j.prototype.bind=function(){gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.glName)};j.prototype.init=function(k){this.length=k.length;this.glName=gl.createBuffer();gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.glName);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Int16Array(k),gl.STATIC_DRAW);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null)};j.prototype.draw=function(l,k){gl.drawElements(l,k?k:this.length,gl.UNSIGNED_SHORT,0)};return j}());e.WebGL_IndexBuffer=a;var f=(function(){function j(m,k){this.width=m;this.height=k;var l=gl.createFramebuffer();this.framebuffer=l;var n=gl.createRenderbuffer();this.depthbuffer=n;var o=gl.createTexture();this.targetTexture=o}j.prototype.bindFrameBuffer=function(){gl.bindFramebuffer(gl.FRAMEBUFFER,this.framebuffer)};j.prototype.bindDepthBuffer=function(){gl.bindRenderbuffer(gl.RENDERBUFFER,this.depthbuffer);gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_COMPONENT16,this.width,this.height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,this.depthbuffer)};j.prototype.renderToTexure=function(){gl.bindTexture(gl.TEXTURE_2D,this.targetTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,this.width,this.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,this.targetTexture,0)};j.prototype.renderToShadowTexure=function(){gl.bindTexture(gl.TEXTURE_2D,this.targetTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,this.width,this.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,this.targetTexture,0)};j.prototype.renderToCubeTexture=function(k){gl.bindTexture(gl.TEXTURE_CUBE_MAP,this.targetTexture);for(var l=0;l<k.length;l++){gl.texImage2D(k[l],0,gl.RGBA,this.width,this.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null)}gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MAG_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MIN_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE)};j.prototype.releaseCubeTex=function(){gl.bindTexture(gl.TEXTURE_CUBE_MAP,null);gl.bindRenderbuffer(gl.RENDERBUFFER,null);gl.bindFramebuffer(gl.FRAMEBUFFER,null)};j.prototype.release=function(){gl.bindTexture(gl.TEXTURE_2D,null);gl.bindRenderbuffer(gl.RENDERBUFFER,null);gl.bindFramebuffer(gl.FRAMEBUFFER,null)};return j}());e.WebGL_FrameBuffer=f})(EcognitaMathLib||(EcognitaMathLib={}));var Utils;(function(a){var b=(function(){function c(){this.items={}}c.prototype.set=function(d,e){this.items[d]=e};c.prototype["delete"]=function(d){return delete this.items[d]};c.prototype.has=function(d){return d in this.items};c.prototype.get=function(d){return this.items[d]};c.prototype.len=function(){return Object.keys(this.items).length};c.prototype.forEach=function(e){for(var d in this.items){e(d,this.items[d])}};return c}());a.HashSet=b})(Utils||(Utils={}));var EcognitaWeb3DFunction;(function(c){var b=(function(){function d(g,e){var f=this;this.canvas=g;this.chkWebGLEnvi();this.vbo=new Array();this.ibo=new Array();this.Texture=new Array();this.matUtil=new EcognitaMathLib.WebGLMatrix();this.quatUtil=new EcognitaMathLib.WebGLQuaternion();this.extHammer=new EcognitaMathLib.Hammer_Utils(this.canvas);this.shaders=new Utils.HashSet();e.forEach(function(i){var h=new EcognitaMathLib.WebGL_Shader(Shaders,i+"-vert",i+"-frag");f.shaders.set(i,h)})}d.prototype.loadTexture=function(h){var g=this;var e=null;var f=EcognitaMathLib.imread(h);f.onload=(function(){e=new EcognitaMathLib.WebGL_Texture(4,false,f);g.Texture.push(e)})};d.prototype.chkWebGLEnvi=function(){try{gl=this.canvas.getContext("webgl")||this.canvas.getContext("experimental-webgl")}catch(f){}if(!gl){throw new Error("Could not initialise WebGL")}};return d}());c.InitWeb3DEnv=b;var a=(function(e){__extends(d,e);function d(h){var g=this;var f=["filterScene","laplacianFilter"];g=e.call(this,h,f)||this;g.initModel();g.settingUniform();g.regisEvent();g.settingRenderPipeline();g.regisLoopFunc();return g}d.prototype.initModel=function(){var g=new EcognitaMathLib.TorusModel(64,64,1,2,[1,1,1,1],true,false);var j=new EcognitaMathLib.WebGL_VertexBuffer();var h=new EcognitaMathLib.WebGL_IndexBuffer();this.vbo.push(j);this.ibo.push(h);j.addAttribute("position",3,gl.FLOAT,false);j.addAttribute("normal",3,gl.FLOAT,false);j.addAttribute("color",4,gl.FLOAT,false);j.init(g.data.length/10);j.copy(g.data);h.init(g.index);var f=[-1,1,0,1,1,0,-1,-1,0,1,-1,0];var l=new EcognitaMathLib.BoardModel(f,undefined,false,false,true);var k=new EcognitaMathLib.WebGL_VertexBuffer();var i=new EcognitaMathLib.WebGL_IndexBuffer();this.vbo.push(k);this.ibo.push(i);k.addAttribute("position",3,gl.FLOAT,false);k.addAttribute("texCoord",2,gl.FLOAT,false);l.index=[0,2,1,2,3,1];k.init(l.data.length/5);k.copy(l.data);i.init(l.index)};d.prototype.settingUniform=function(){var h=new Array();var g=this.shaders.get("filterScene");var i=this.shaders.get("laplacianFilter");h.push(g.uniformIndex("mvpMatrix"));h.push(g.uniformIndex("invMatrix"));h.push(g.uniformIndex("lightDirection"));h.push(g.uniformIndex("eyeDirection"));h.push(g.uniformIndex("ambientColor"));var f=new Array();f.push(i.uniformIndex("mvpMatrix"));f.push(i.uniformIndex("texture"));f.push(i.uniformIndex("coef"));this.uniLocation_f=h;this.uniLocation_s=f};d.prototype.settingRenderPipeline=function(){gl.enable(gl.DEPTH_TEST);gl.depthFunc(gl.LEQUAL);gl.enable(gl.CULL_FACE)};d.prototype.regisEvent=function(){var j=this;var i=0;var h=0;var g=false;var f=this.extHammer;f.on_pan=function(u){var q=u.target;if(!g){g=true;i=q.offsetLeft;h=q.offsetTop}var o=u.center.x-i;var l=u.center.y-h;var s=j.canvas.width;var m=j.canvas.height;var p=1/Math.sqrt(s*s+m*m);var v=o-s*0.5;var t=l-m*0.5;var n=Math.sqrt(v*v+t*t);var k=n*2*Math.PI*p;if(n!=1){n=1/n;v*=n;t*=n}j.usrQuaternion=j.quatUtil.rotate(k,[t,v,0]);if(u.isFinal){g=false}};f.enablePan()};d.prototype.regisLoopFunc=function(){var A=this;var B=0;var g=0;var n=[1,1,1,1,-8,1,1,1,1];var f=[-0.577,0.577,0.577];var z=this.matUtil;var w=this.quatUtil;var i=z.identity(z.create());var h=z.identity(z.create());var r=z.identity(z.create());var y=z.identity(z.create());var l=z.identity(z.create());var t=z.identity(z.create());this.usrQuaternion=w.identity(w.create());var D=512;var F=512;var u=new EcognitaMathLib.WebGL_FrameBuffer(D,F);u.bindFrameBuffer();u.bindDepthBuffer();u.renderToShadowTexure();u.release();var v=this.uniLocation_f;var k=this.uniLocation_s;var s=this.shaders.get("filterScene");var C=this.shaders.get("laplacianFilter");var x=this.vbo[0];var o=this.ibo[0];var p=this.vbo[1];var j=this.ibo[1];var E=function(){B++;if(B%2==0){g++}var m=(B%360)*Math.PI/180;s.bind();u.bindFrameBuffer();var G=EcognitaMathLib.HSV2RGB(g%360,1,1,1);gl.clearColor(G[0],G[1],G[2],G[3]);gl.clearDepth(1);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);var q=new Array();var J=new Array();q=w.ToV3([0,20,0],A.usrQuaternion);J=w.ToV3([0,0,-1],A.usrQuaternion);h=z.viewMatrix(q,[0,0,0],J);r=z.perspectiveMatrix(90,A.canvas.width/A.canvas.height,0.1,100);y=z.multiply(r,h);x.bind(s);o.bind();for(var H=0;H<9;H++){var I=EcognitaMathLib.HSV2RGB(H*40,1,1,1);i=z.identity(i);i=z.rotate(i,H*2*Math.PI/9,[0,1,0]);i=z.translate(i,[0,0,10]);i=z.rotate(i,m,[1,1,0]);l=z.multiply(y,i);t=z.inverse(i);gl.uniformMatrix4fv(v[0],false,l);gl.uniformMatrix4fv(v[1],false,t);gl.uniform3fv(v[2],f);gl.uniform3fv(v[3],q);gl.uniform4fv(v[4],I);o.draw(gl.TRIANGLES)}C.bind();gl.bindFramebuffer(gl.FRAMEBUFFER,null);gl.clearColor(0,0,0,1);gl.clearDepth(1);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);h=z.viewMatrix([0,0,0.5],[0,0,0],[0,1,0]);r=z.orthoMatrix(-1,1,1,-1,0.1,1);y=z.multiply(r,h);gl.activeTexture(gl.TEXTURE0);gl.bindTexture(gl.TEXTURE_2D,u.targetTexture);p.bind(C);j.bind();gl.uniformMatrix4fv(k[0],false,y);gl.uniform1i(k[1],0);gl.uniform1fv(k[2],n);j.draw(gl.TRIANGLES);gl.flush();requestAnimationFrame(E)};E()};return d}(b));c.FilterViewer=a})(EcognitaWeb3DFunction||(EcognitaWeb3DFunction={}));var cvs_web3d=document.getElementById("canvas_web3d");cvs_web3d.width=512;cvs_web3d.height=512;var filterViewer=new EcognitaWeb3DFunction.FilterViewer(cvs_web3d);